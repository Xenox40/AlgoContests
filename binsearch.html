<p>Problem <strong>wyszukiwania</strong> w programowaniu jest jednym z najwaÅ¼niejszych problemÃ³w algorytmicznych. MoÅ¼na <strong>nie tylko</strong> przeszukiwaÄ‡ zbiory liczb, czy innych obiektÃ³w, ale takÅ¼e szukaÄ‡ optymalnego wyniku.</p>
<p><span id="more-210"></span></p>
<h2></h2>
<h2>Wyszukiwanie liniowe &#8211; O(n)</h2>
<p>&nbsp;</p>
<p>Najprostszym i najbardziej trywialnym rozwiÄ…zaniem jest <em><strong>algorytm wyszukiwania liniowego</strong></em>, ktÃ³ry jak sama nazwa wskazuje dziaÅ‚a w czasie <em><strong>O(n).</strong></em></p>
<p>PrzykÅ‚adowa implementacja:</p>
<p>&nbsp;</p><pre class="crayon-plain-tag">int szukaj(int x, vector<int> &amp;v)
{
    for(int i = 0;i &lt; v.size();++i)
    {
        if(v[i] == x)
            return i;
    }
    return -1;
}</pre><p>&nbsp;</p>
<p>PowyÅ¼szy kod sprawdza kaÅ¼dÄ… liczbÄ™ ze zbioru i jeÅ›li jest natrafi na szukanÄ… wartoÅ›Ä‡ zwraca jej <strong>indeks</strong>(gdy w tablicy jest wiÄ™cej takich samych liczb, to <strong>funkcja zwrÃ³ci indeks pierwszej</strong>), gdy takowej nie ma to funkcji zwrÃ³ci <strong>-1</strong>.</p>
<p>Bardzo Å‚atwo moÅ¼na przeksztaÅ‚ciÄ‡ powyÅ¼sze rozwiÄ…zanie, tak by zwracaÅ‚o indeks <strong>ostatniego wystÄ…pienie</strong> szukanego elementu.</p>
<p></p><pre class="crayon-plain-tag">int szukaj(int x, vector&lt;int&gt; &amp;v)
{
    for(int i = v.size()-1;i &gt;= 0;--i)
    {
        if(v[i] == x)
            return i;
    }
    return -1;
}</pre><p> </p>
<p>&nbsp;</p>
<p>To rozwiÄ…zanie staje siÄ™ jednak nieefektywne, gdy szukamy np. wiele liczb w tablicy. <em><strong>Natchnienia do wymyÅ›lenia czegoÅ› szybszego musimy szukaÄ‡ w codziennym Å¼yciu <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f609.png" alt="ğŸ˜‰" class="wp-smiley" style="height: 1em; max-height: 1em;" /></strong></em></p>
<hr />
<p>&nbsp;</p>
<h2>W poszukiwaniu lepszego rozwiÄ…zania</h2>
<p>Skoro potrzebujemy szybszego algorytmu szukajÄ…cego, przyjrzyjmy siÄ™ jak sobie z tym radzimy na co dzieÅ„.Â  Zadajmy sobie pytanie:</p>
<p>&nbsp;</p>
<blockquote><p>Jak poszukujemy frazy w sÅ‚owniku?</p>
<p>Czy robimy to tak jak w naszym poprzednim algorytmie?</p></blockquote>
<p>&nbsp;</p>
<p>OdpowiedÅº jest oczywista: <em><strong>NIE!</strong></em></p>
<p>PrzecieÅ¼ nikt nie bÄ™dzie sprawdzaÅ‚ kaÅ¼dego jednego sÅ‚Ã³wka w sÅ‚owniku. To potrwaÅ‚o by wieki. Korzystamy z fajnej wÅ‚asnoÅ›ci sÅ‚ownika. SÅ‚ownik jest przecieÅ¼ posortowany alfabetycznie. Przez to wiemy, Å¼e jak szukamy czegoÅ› na literÄ™ &#8216;R&#8217;, a sÅ‚ownik mamy otworzony na literze &#8216;L&#8217;, to wiemy, Å¼e wszystkie poprzednie strony moÅ¼na juÅ¼ odrzuciÄ‡, bo wiadomo, Å¼e szukanego wyrazu tam nie bÄ™dzie. W taki sposÃ³b coraz bardziej zawÄ™Å¼amy pole przeszukiwania i po kilku sprawdzeniach mamy wynik, pomimo Å¼e wyrazÃ³w jest <em><strong>ponad 100 tysiÄ™cy</strong></em>!</p>
<p>Jak zatem przenieÅ›Ä‡ naszÄ… znakomitÄ… metodÄ™ szukania do funkcji?</p>
<hr />
<p>&nbsp;</p>
<h2>Wyszukiwanie &#8220;z Å¼ycia wziÄ™te&#8221; binarne &#8211; O(log n)</h2>
<p>&nbsp;</p>
<p>Jeszcze przed tworzeniem jakichkolwiek implementacji naleÅ¼aÅ‚oby upewniÄ‡ siÄ™ czy nasze rozwiÄ…zanie jest rzeczywiÅ›cie takie idealne. Musimy bowiem pamiÄ™taÄ‡, Å¼e zadziaÅ‚o ono tylko w przypadku, gdy nasz tablica <strong>jest posortowana</strong>, inaczej nigdy nie moÅ¼emy zaÅ‚oÅ¼yÄ‡, Å¼e naszego elementu na pewno nie bÄ™dzie w jakimÅ› przedziale. Na nasze szczÄ™Å›cie znane sÄ… algorytmy sortowanie w czasie <em><strong>O(n log n)</strong></em>, wiÄ™c niewiele gorszym od liniowego, a przecieÅ¼ sortowaÄ‡ bÄ™dziemy tylko raz. O tych algorytmach powstanÄ… posty w przyszÅ‚oÅ›ci, dziÅ› mogÄ™ poleciÄ‡ tylko funkcjÄ™ <em><strong>sort</strong></em> z C++ lub (lepiej) zagÅ‚Ä™bienie siÄ™ w temat i poszukanie materiaÅ‚Ã³w na wÅ‚asnÄ… rÄ™kÄ™.</p>
<p>&nbsp;</p>
<h5>Skoro zaÅ‚oÅ¼enia mamy za sobÄ… przejdÅºmy do meritum.</h5>
<p>&nbsp;</p>
<p>PrzejdÅºmy zatem do pierwszego kroku naszego algorytmu, czyli:</p>
<p>&nbsp;</p>
<blockquote><p>Jak wybraÄ‡ element do sprawdzenia, tak by odrzuciÄ‡ jak najwiÄ™cej rzeczy?</p></blockquote>
<p>&nbsp;</p>
<p>OdpowiedÅº to oczywiÅ›cie podzieliÄ‡ na <em><strong>2 rÃ³wne czÄ™Å›ci</strong></em>. JeÅ›li wybierzemy jakikolwiek inny element podziaÅ‚u niÅ¼ Å›rodek zawsze istnieje szansa(50%), Å¼e szukany element bÄ™dzie w tej wiÄ™kszej czÄ™Å›ci.</p>
<p>NastÄ™pny krok to sprawdzenie zgodnoÅ›ci elementu i wybranie przedziaÅ‚u, co juÅ¼ trudne nie jest.</p>
<ul>
<li>RÃ³wna siÄ™ &#8211; znaleÅºliÅ›my szukanÄ… wartoÅ›Ä‡;</li>
<li>Za duÅ¼a &#8211; szukaÄ‡ powinniÅ›my wÅ›rÃ³d mniejszych liczb</li>
<li>Za maÅ‚a &#8211; szukaÄ‡ musimy wÅ›rÃ³d wiÄ™kszych liczb</li>
</ul>
<p>&nbsp;</p>
<p>Teraz zostaÅ‚o nam tylko to zaimplementowaÄ‡:</p>
<p>&nbsp;</p><pre class="crayon-plain-tag">int szukaj(int x, vector&lt;int&gt; &amp;v)
{
	int poczatek = 0;
	int koniec = v.size()-1;
	while (poczatek &lt; koniec)
	{
		int srodek = (poczatek + koniec) / 2;
		if(v[srodek] == x)
			return srodek;
		
		if (v[srodek] &lt; x)	
			poczatek = srodek + 1;
		else
			koniec = srodek - 1;
	}
	return -1;
}</pre><p>&nbsp;</p>
<p>PowyÅ¼szy kod realizuje nasz pomysÅ‚, ktÃ³ry nosi nazwÄ™ <em><strong>wyszukiwanie binarne</strong></em>. Prawdopodobnie nazwa wziÄ™Å‚a siÄ™ z tego, Å¼e podstawÄ… szukania jest dzielenia przez <em><strong>2</strong></em>. ZÅ‚oÅ¼onoÅ›Ä‡ tego algorytmu to <em><strong>O(log n)</strong></em>, wiÄ™c dla wyszukania liczby w tablicy majÄ…cej <em><strong>milion</strong></em> elementÃ³w potrzeba zaledwie <em><strong>20</strong></em> sprawdzeÅ„, nawet gdy danej liczby nie ma w naszej tablicy. Jest to zatem ogromne przyspieszenie, dziÄ™ki ktÃ³remu moÅ¼na rozwiÄ…zywaÄ‡ wiele problemÃ³w.</p>
<p>Technika zastosowana przy tworzeniu tego rozwiÄ…zania rÃ³wnieÅ¼ ma wÅ‚asnÄ… nazwÄ™: &#8220;<em><strong>Dziel i zwyciÄ™Å¼aj</strong></em>&#8220;. Jej zastosowanie jest bardzo szerokie i warto o niej pamiÄ™taÄ‡. Polega ona na <em><strong>dzieleniu problemu na mniejsze</strong></em>, co ma pozwoliÄ‡ <em><strong>zmniejszyÄ‡ czas</strong></em> dziaÅ‚ania programu.</p>
<hr />
<h2></h2>
<h1>Podsumowanie</h1>
<p>ZachÄ™cam kaÅ¼dego czytelnika do zapoznania siÄ™ z Ä‡wiczeniami dostÄ™pnymi <a href="http://wazniak.mimuw.edu.pl/index.php?title=Wst%C4%99p_do_programowania_/_%C4%86wiczenia_5">tutaj</a>. W czÄ™Å›ci 2 bÄ™dÄ™ omawiaÅ‚ rozwiÄ…zania do nich i tym samym praktyczne zastosowania wyszukiwania binarnego. ZachÄ™cam do zadawania pytaÅ„ i pisania wszelakich uwag w sekcji komentarzy. Mam nadziejÄ™, Å¼e wpis siÄ™ podobaÅ‚ i Å¼e wszystko byÅ‚o zrozumiaÅ‚e <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f609.png" alt="ğŸ˜‰" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>
<p>ArtykuÅ‚ <a rel="nofollow" href="http://www.xenoxdev.pl/algortytmika-od-podstaw/problem-wyszukiwania-w-programowaniu-cz-1/">Problem wyszukiwania w programowaniu &#8211; cz. 1 (wyszukiwanie binarne)</a> pochodzi z serwisu <a rel="nofollow" href="http://www.xenoxdev.pl">XENOXDEV.PL</a>.</p>
