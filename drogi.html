<p>W zadaniu &#8220;<em><strong>Drogi</strong></em>&#8221; musimy pom贸c kr贸lowi Bajtazarowi w obliczeniu ile minimalnie dr贸g jednokierunkowych trzeba dobudowa, aby dao si dojecha z ka偶dego miasta do ka偶dego innego.</p>
<p>Polecenie do prosto mo偶na przeksztaci na jzyk graf贸w. Nale偶y doda minimaln liczb <em><strong>krawdzi skierowanych</strong></em> do grafu wejciowego, tak by powstay graf by <em><strong>silnie sp贸jny</strong></em>. W om贸wienie, tak samo jak w treci, zostao przyjte, 偶e <strong><em>n </em></strong>to <strong>liczba wierzchok贸w</strong>, <em><strong>m</strong> </em>to <strong>liczba krawdzi</strong>.</p>
<p><span id="more-156"></span></p>
<h2>Rozwizanie brutalne</h2>
<p>Po przeczytaniu zadania pierwszym co si nasunie, mo偶e by przegldanie wszystkich wierzchok贸w w grafie i dla ka偶dego z ich dzieci sprawdzenie czy da si w jakikolwiek spos贸b wr贸ci do rodzica.</p>
<p>Dla pokazanego wy偶ej testu nasz poczy miasta: &#8220;<em>6 i 1</em>&#8221; oraz &#8220;<em>4 i 3</em>&#8220;, gdy偶 z &#8220;<em>6 nie da si wr贸ci do 1</em>&#8220;, podobnie jak z &#8220;<em>4 do 3</em>&#8220;, i zwr贸ci wynik<em> 2</em>.</p>
<p>Rozwizanie zmusza nas jednak do przeszukania grafu dla ka偶dej krawdzi, bo:</p>
<ul>
<li>przegldajc wszystkich ssiad贸w ka偶dego wierzchoka &#8220;przejdziemy&#8221; ka偶d krawdzi;</li>
<li>dla ka偶dego ssiada musimy przeszuka by mo偶e nawet cay graf, aby dowiedzie si czy da si wr贸ci do miasta, z kt贸rego przyszlimy;</li>
</ul>
<p>Przez to cao dziaa w pesymistycznym czasie <strong>O(m*(n+m))</strong>, co jest stanowczo za wolne dla ograniczenia <strong>m = 10<sup>5</sup></strong>.</p>
<hr />
<h2></h2>
<h2>Rozwizanie wzorcowe</h2>
<p>&nbsp;</p>
<h5>Implementacja tego rozwizanie znajduje si na moim <a href="https://github.com/Xenox40/AlgoContests/blob/master/PA 2005/dro.cpp">GitHubie</a>.</h5>
<p>&nbsp;</p>
<p>W poprzednim rozwizaniu nie skorzystalimy z tego co nasuwa problem: <em><strong>Silnie Sp贸jnych Skadowych</strong></em>(w silnie sp贸jnej skadowej da si do z ka偶dego wierzchoka do ka偶dego innego). W naszym zadaniu musimy doprowadzi do sytuacji, w kt贸rej cay graf jest <strong>jedn silnie sp贸jna skadow</strong>. Na pocztku wyznaczmy wic SSS&#8217;y naszego wejciowego grafu:</p>
<ul>
<li>obliczamy czasy przetworzenia wierzchok贸w w kolejnoci<em><strong> post-order</strong></em> algorytmem przeszukiwania w gb (DFS).</li>
<li>wywoujemy algorytm DFS dla grafu transponowanego(odwrotnego) w kolejnoci <em><strong>malejcych czas贸w przetworzenia wierzchok贸w</strong></em>. Wszystkie wierzchoki w jednym drzewie przeszukiwania w gb nale偶 do <em><strong>jednej silnie sp贸jnej skadowej</strong></em>.</li>
</ul>
<p>W mojej implementacji zajmuj si tym funkcja &#8220;<em><strong>computeSSS()</strong></em>&#8221; .</p>
<p>Znajc numer SSS, do kt贸rej nale偶y ka偶dy z wierzchok贸w, mo偶emy teraz zbudowa <em><strong>2 grafy</strong></em>, kt贸rych wierzchokami, bd SSS&#8217;y, a krawdziami poczenia <em><strong>jednokierunkowe</strong></em> pomidzy skadowymi, z tym 偶e w 2 grafie dodajemy krawdzie<em><strong> odwrotne</strong></em> (dlaczego? &#8211; o tym za chwile <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f609.png" alt="" class="wp-smiley" style="height: 1em; max-height: 1em;" /> ). Nastpnie tworzymy <em><strong>2 zmienne</strong></em> odpowiadajce za wynik w danym grafie oraz przegldamy wierzchoki w grafie. Jeli kt贸ry z nich nie ma krawdzi wychodzcych zwikszamy jego wynik o <em><strong>1</strong></em>. Naszym wynikiem wyjciowym bdzie <em><strong>wiksza</strong></em> z tych 2 liczb.</p>
<p>Magia &#8211; czy偶 nie? <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f600.png" alt="" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>
<p>&nbsp;</p>
<h4>Dlaczego zliczamy &#8220;puste&#8221; wierzchoki?</h4>
<p>Zauwa偶my, 偶e najbardziej optymalne bdzie wykorzystanie<em><strong> istniejcych krawdzi</strong></em> i dobudowywanie nowych tylko, gdy ju偶 normalnie nie mo偶emy i dalej. Oczywicie ostatnie &#8220;koc贸wki&#8221; trzeba podpi do pocztku by powsta <em><strong>cykl</strong></em>.</p>
<p>&nbsp;</p>
<p>NO FOTO <br/>Dla danego przykadu musimy zwr贸ci 2, gdy偶 mam 2 koce i ka偶dy z nich musi mie krawd藕 do pocztku.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h4>Dlaczego potrzebujemy 2 graf(odwr贸cony)?</h4>
<p>Mo偶e zdarzy si sytuacja, gdy pocztkowych wierzchok贸w bdzie <strong>wicej</strong> ni偶 kocowych, a my zliczymy po 1 krawdzie od kocowej(to mo偶e nie wystarczy).</p>
<p>&nbsp;</p>
<p>NO FOTO <br/>W tym przykadzie wynik dla pierwszego grafu wynosi <strong>1</strong>, gdy偶 jest tylko <strong>1 koniec</strong>(nr 3), a poprawna odpowied藕 to <strong>2</strong>. Tak odpowied藕 zwr贸ci<strong> odwr贸cony graf</strong>, dla kt贸rego kocami bd pocztki normalnego.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Jak atwo si domyle nie bdzie wicej przypadk贸w, gdy偶 mamy, albo wicej zakocze, albo wicej pocztk贸w(dla r贸wnoci wyniki bd r贸wne).</p>
<p>&nbsp;</p>
<h2>Podsumowanie</h2>
<p>&nbsp;</p>
<p>Zadanie nie byo bardzo trudne, ale wymagao dogbnej analizy. Bardzo atwo byo te偶 przeoczy sytuacj nr 2, przez co <em><strong>tracilimy okoo 40pkt</strong></em>.</p>
<p>Mam nadziej, 偶e om贸wienie byo zrozumiae. Zachcam do napisania opinii lub wszelakich pyta w sekcji komentarzy <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f642.png" alt="" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>
<p>&nbsp;</p>
<p>Artyku <a rel="nofollow" href="http://www.xenoxdev.pl/za/drogi/">Drogi &#8211; Potyczki Algorytmiczne 2005(Fina)</a> pochodzi z serwisu <a rel="nofollow" href="http://www.xenoxdev.pl">XENOXDEV.PL</a>.</p>
