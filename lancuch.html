<p>Zadanie &#8220;<strong>acuch Kolorowy</strong>&#8221; polega na sprawdzeniu ile jest &#8220;<em>idealnych</em>&#8221; sp贸jnych podcig贸w danego cigu koralik贸w. Idealny podcig to taki, kt贸ry posiada dokadnie <em>l<sub>i</sub></em> koralik贸w koloru <em>c<sub>i</sub></em>.</p>
<p><span id="more-96"></span></p>
<h2>Rozwizanie brutalne</h2>
<p>Pierwszym pomysem jest zatem zaimplementowanie dokadnie tego o co nas prosz:</p>
<ul>
<li>zapamitujemy ilo koralik贸w ka偶dego koloru w idealnym cigu oraz jego dugo;</li>
<li>bierzemy ka偶dy sp贸jny podcig, o dugoci idealnego cigu, naszej tablicy koralik贸w i sprawdzamy czy liczba ka偶dego z kolor贸w si zgadza, gdy tak jest powikszamy wynik o 1;</li>
</ul>
<p>Takie rozwizanie wymaga jednak od nas cigego przechodzenia po tablicy kolor贸w co sprawia, 偶e za takie rozwizanie dostaniemy ok <strong>50pkt</strong>.</p>
<p>&nbsp;</p>
<h4>Przykadowa implementacja:</h4>
<pre class="brush: cpp; title: ; notranslate">
/*
sumColors - dugo idealnego cigu
idealSequence - tablica iloci ka偶dego koloru w idealnym cigu
amountColors, colors - ilo i rodzaj danego koloru(z wejscia)
sequenceColors - tablica iloci ka偶dego koloru w sprawdzanym podcigu
sequence - cig koralik贸w
*/
int sumColors = 0;
for(int i = 0;i &lt; m;++i)
{
 idealSquence[colors[i]] = amountColors[i];
 sumColors += amountColors[i];
}
for(int i = 0;i &lt; sumColors-1;++i)
 ++sequenceColors[sequence[i]];

for(int i = sumColors-1;i &lt; n;++i)
{
 bool ideal = true;
 ++sequenceColors[sequence[i]];
 for(int j = 0;j &lt; m;++j)
 {
 if(idealSequence[colors[j]] != sequenceColors[colors[j]])
 ideal = false;
 }
 if(ideal)
 ++result;
    --sequenceColors[sequence[i-sumColors+1]];
}
</pre>
<hr />
<h2></h2>
<h2>Rozwizanie wzorcowe</h2>
<p>Rozwizanie wzorcowe polega na zastosowaniu techniki <em><strong>haszowania</strong></em>, kt贸ra pozwala w czasie staym sprawdza czy dany podcig jest idealny.</p>
<p><em>Haszowanie</em> pozwala nam zapisa dany cig jako liczba, kt贸ra dziki zastosowaniu<strong> potg du偶ej liczby pierwszej modulo inna liczba pierwsza</strong>, prawie na pewno bdzie unikalna i nie pojawi si przy innym cigu.</p>
<pre class="brush: cpp; title: ; notranslate">
long long fixMod(long long n)
{
    return ((n%mod)+mod)%mod;
}
long long hashC(vector&lt;int&gt; &amp;idealSequence)
{
    long long hash = 0;
    for(int i = 0;i &lt; idealSequence.size();++i)
    {
        hash += powers[idealSequence[i]];
        hash  = fixMod(hash);
    }
    return hash;
}
 </pre>
<p>Powy偶szy kod sumuje potgi liczby pierwszej, kt贸rej wykadnikami s kolejne kolory idealnego cigu, a potem wykonuje &#8220;magiczne&#8221; modulo <img src="https://s.w.org/images/core/emoji/2.2.1/72x72/1f609.png" alt="" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>
<p>Funkcja <em><strong>fixMod</strong></em> ma zwr贸ci warto z przedziau od <strong>0 do mod</strong>. Rozwa偶ajc 2 mo偶liwe przypadki dla &#8216;n'(ujemne lub nieujemne) mo偶na zauwa偶y, 偶e zwracana warto zawsze bdzie z chcianego przedziau.</p>
<p>Teraz mo偶emy wykorzysta t sam technik do sprawdzania czy nasz podcig jest &#8220;idealny&#8221;. Haszujemy podsowo dugoci naszego wzorca i sprawdzamy czy jest identyczne. Potem przesuwamy si w prawo odejmujc kolor z pocztku i dodajc nowy na koniec. Cae rozwizanie dziaa w czasie <strong>O(n)</strong> i daje <strong>100pkt</strong> za to zadanie.</p>
<hr />
<h2>Podsumowanie</h2>
<p>Zachcam do zgbienia tematu haszowania i szerszego zapoznania si z mo偶liwociami tej techniki oraz zadawania pyta w komentarzach. Peen kod z rozwizaniem zadania znajduj si na <a href="https://github.com/Xenox40/AlgoContests">GitHubie</a>.</p>
<p>Artyku <a rel="nofollow" href="http://www.xenoxdev.pl/za/lancuch-kolorowy/">acuch kolorowy &#8211; Fina XX OI</a> pochodzi z serwisu <a rel="nofollow" href="http://www.xenoxdev.pl">XENOXDEV.PL</a>.</p>
